# Build a Google Calendar Server

Create a production-ready MCP server that integrates with Google Calendar API. This tutorial covers OAuth authentication, cloud deployment, and real-world API integration.

## What You'll Build

A complete MCP server that:
- Authenticates with Google Calendar using OAuth 2.0
- Lists upcoming events
- Creates and manages calendar events
- Handles API rate limits and errors
- Runs securely in the cloud

## Prerequisites

- Python 3.8+ or Node.js 16+
- Google Cloud Platform account
- Basic understanding of OAuth 2.0
- Completion of [weather server tutorial](/docs/tutorials/weather-server)

## Step 1: Google Cloud Setup

### Create a Google Cloud Project

1. Go to [Google Cloud Console](https://console.cloud.google.com/)
2. Create a new project or select existing one
3. Enable the Google Calendar API:
   - Go to **APIs & Services** â†’ **Library**
   - Search for "Google Calendar API"
   - Click **Enable**

### Create OAuth Credentials

1. Go to **APIs & Services** â†’ **Credentials**
2. Click **Create Credentials** â†’ **OAuth 2.0 Client IDs**
3. Configure the consent screen if prompted
4. Select **Desktop application** as application type
5. Download the credentials JSON file
6. Save it as `credentials.json`

## Step 2: Install Dependencies

### Python Dependencies

```bash
pip install mcp google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client
```

### Node.js Dependencies

```bash
npm install @modelcontextprotocol/sdk googleapis
```

## Step 3: Create the Calendar Server

### Python Implementation

Create `calendar_server.py`:

```python
import asyncio
import json
import os
from datetime import datetime, timedelta
from typing import Any, Sequence, Optional
import pickle
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError

from mcp.server import Server
from mcp.server.models import InitializationOptions
from mcp.server.stdio import stdio_server
from mcp.types import Tool, TextContent

# OAuth 2.0 scopes
SCOPES = ['https://www.googleapis.com/auth/calendar']

# Initialize server
server = Server("calendar-server")

class GoogleCalendarClient:
    """Google Calendar API client with OAuth authentication."""
    
    def __init__(self, credentials_file: str = "credentials.json", token_file: str = "token.pickle"):
        self.credentials_file = credentials_file
        self.token_file = token_file
        self.service = None
        self._authenticate()
    
    def _authenticate(self):
        """Handle OAuth 2.0 authentication."""
        creds = None
        
        # Load existing token
        if os.path.exists(self.token_file):
            with open(self.token_file, 'rb') as token:
                creds = pickle.load(token)
        
        # If no valid credentials, start OAuth flow
        if not creds or not creds.valid:
            if creds and creds.expired and creds.refresh_token:
                creds.refresh(Request())
            else:
                if not os.path.exists(self.credentials_file):
                    raise ValueError(f"Credentials file not found: {self.credentials_file}")
                
                flow = InstalledAppFlow.from_client_secrets_file(
                    self.credentials_file, SCOPES)
                creds = flow.run_local_server(port=0)
            
            # Save credentials for next run
            with open(self.token_file, 'wb') as token:
                pickle.dump(creds, token)
        
        self.service = build('calendar', 'v3', credentials=creds)
    
    async def list_events(self, max_results: int = 10, days_ahead: int = 7) -> list:
        """List upcoming events."""
        try:
            # Get events from now to days_ahead
            now = datetime.utcnow().isoformat() + 'Z'
            future = (datetime.utcnow() + timedelta(days=days_ahead)).isoformat() + 'Z'
            
            events_result = self.service.events().list(
                calendarId='primary',
                timeMin=now,
                timeMax=future,
                maxResults=max_results,
                singleEvents=True,
                orderBy='startTime'
            ).execute()
            
            events = events_result.get('items', [])
            return events
        except HttpError as e:
            raise ValueError(f"Google Calendar API error: {e}")
    
    async def create_event(self, title: str, start_time: str, end_time: str, 
                          description: str = "", location: str = "") -> dict:
        """Create a new calendar event."""
        try:
            event = {
                'summary': title,
                'location': location,
                'description': description,
                'start': {
                    'dateTime': start_time,
                    'timeZone': 'UTC',
                },
                'end': {
                    'dateTime': end_time,
                    'timeZone': 'UTC',
                },
            }
            
            created_event = self.service.events().insert(
                calendarId='primary',
                body=event
            ).execute()
            
            return created_event
        except HttpError as e:
            raise ValueError(f"Failed to create event: {e}")
    
    async def get_event(self, event_id: str) -> dict:
        """Get a specific event by ID."""
        try:
            event = self.service.events().get(
                calendarId='primary',
                eventId=event_id
            ).execute()
            return event
        except HttpError as e:
            raise ValueError(f"Failed to get event: {e}")
    
    async def delete_event(self, event_id: str) -> bool:
        """Delete an event by ID."""
        try:
            self.service.events().delete(
                calendarId='primary',
                eventId=event_id
            ).execute()
            return True
        except HttpError as e:
            raise ValueError(f"Failed to delete event: {e}")

# Initialize calendar client
try:
    calendar_client = GoogleCalendarClient()
except Exception as e:
    print(f"Failed to initialize Google Calendar client: {e}")
    calendar_client = None

@server.list_tools()
async def list_tools() -> list[Tool]:
    """List available calendar tools."""
    return [
        Tool(
            name="list_events",
            description="List upcoming calendar events",
            inputSchema={
                "type": "object",
                "properties": {
                    "max_results": {
                        "type": "integer",
                        "description": "Maximum number of events to return (default: 10)",
                        "default": 10,
                        "minimum": 1,
                        "maximum": 50
                    },
                    "days_ahead": {
                        "type": "integer",
                        "description": "Number of days ahead to look for events (default: 7)",
                        "default": 7,
                        "minimum": 1,
                        "maximum": 365
                    }
                },
                "additionalProperties": False
            }
        ),
        Tool(
            name="create_event",
            description="Create a new calendar event",
            inputSchema={
                "type": "object",
                "properties": {
                    "title": {
                        "type": "string",
                        "description": "Event title/summary"
                    },
                    "start_time": {
                        "type": "string",
                        "description": "Start time in ISO format (e.g., 2024-01-15T10:00:00Z)"
                    },
                    "end_time": {
                        "type": "string",
                        "description": "End time in ISO format (e.g., 2024-01-15T11:00:00Z)"
                    },
                    "description": {
                        "type": "string",
                        "description": "Event description (optional)",
                        "default": ""
                    },
                    "location": {
                        "type": "string",
                        "description": "Event location (optional)",
                        "default": ""
                    }
                },
                "required": ["title", "start_time", "end_time"]
            }
        ),
        Tool(
            name="delete_event",
            description="Delete a calendar event by ID",
            inputSchema={
                "type": "object",
                "properties": {
                    "event_id": {
                        "type": "string",
                        "description": "The ID of the event to delete"
                    }
                },
                "required": ["event_id"]
            }
        )
    ]

@server.call_tool()
async def call_tool(name: str, arguments: dict[str, Any]) -> Sequence[TextContent]:
    """Handle tool calls."""
    if not calendar_client:
        return [TextContent(type="text", text="âŒ Calendar client not initialized. Check your credentials.")]
    
    try:
        if name == "list_events":
            max_results = arguments.get("max_results", 10)
            days_ahead = arguments.get("days_ahead", 7)
            
            events = await calendar_client.list_events(max_results, days_ahead)
            
            if not events:
                return [TextContent(type="text", text="ðŸ“… No upcoming events found.")]
            
            result = f"ðŸ“… Upcoming Events (next {days_ahead} days):\n\n"
            
            for event in events:
                start = event['start'].get('dateTime', event['start'].get('date'))
                title = event.get('summary', 'No Title')
                
                # Format datetime
                try:
                    if 'T' in start:
                        dt = datetime.fromisoformat(start.replace('Z', '+00:00'))
                        formatted_time = dt.strftime('%Y-%m-%d %H:%M')
                    else:
                        formatted_time = start
                except:
                    formatted_time = start
                
                result += f"â€¢ **{title}**\n"
                result += f"  ðŸ“… {formatted_time}\n"
                
                if event.get('location'):
                    result += f"  ðŸ“ {event['location']}\n"
                
                if event.get('description'):
                    desc = event['description'][:100] + "..." if len(event['description']) > 100 else event['description']
                    result += f"  ðŸ“ {desc}\n"
                
                result += f"  ðŸ†” ID: {event['id']}\n\n"
            
            return [TextContent(type="text", text=result)]
        
        elif name == "create_event":
            title = arguments.get("title")
            start_time = arguments.get("start_time")
            end_time = arguments.get("end_time")
            description = arguments.get("description", "")
            location = arguments.get("location", "")
            
            if not all([title, start_time, end_time]):
                raise ValueError("Title, start_time, and end_time are required")
            
            # Validate datetime format
            try:
                datetime.fromisoformat(start_time.replace('Z', '+00:00'))
                datetime.fromisoformat(end_time.replace('Z', '+00:00'))
            except ValueError:
                raise ValueError("Invalid datetime format. Use ISO format like 2024-01-15T10:00:00Z")
            
            event = await calendar_client.create_event(
                title, start_time, end_time, description, location
            )
            
            result = f"âœ… Event created successfully!\n\n"
            result += f"ðŸ“… **{event['summary']}**\n"
            result += f"ðŸ• {start_time} to {end_time}\n"
            if location:
                result += f"ðŸ“ {location}\n"
            result += f"ðŸ†” Event ID: {event['id']}\n"
            result += f"ðŸ”— Link: {event.get('htmlLink', 'N/A')}"
            
            return [TextContent(type="text", text=result)]
        
        elif name == "delete_event":
            event_id = arguments.get("event_id")
            if not event_id:
                raise ValueError("Event ID is required")
            
            # Get event details before deleting
            try:
                event = await calendar_client.get_event(event_id)
                event_title = event.get('summary', 'Unknown Event')
            except:
                event_title = "Unknown Event"
            
            success = await calendar_client.delete_event(event_id)
            
            if success:
                return [TextContent(type="text", text=f"âœ… Event '{event_title}' deleted successfully")]
            else:
                return [TextContent(type="text", text="âŒ Failed to delete event")]
        
        else:
            raise ValueError(f"Unknown tool: {name}")
    
    except Exception as e:
        return [TextContent(type="text", text=f"âŒ Error: {str(e)}")]

async def main():
    """Main server entry point."""
    async with stdio_server() as (read_stream, write_stream):
        await server.run(
            read_stream,
            write_stream,
            InitializationOptions(
                server_name="calendar-server",
                server_version="1.0.0",
                capabilities=server.get_capabilities(
                    notification_options=None,
                    experimental_capabilities=None
                )
            )
        )

if __name__ == "__main__":
    asyncio.run(main())
```

## Step 4: Initial Authentication

Run the server once to complete OAuth setup:

```bash
python calendar_server.py
```

This will:
1. Open your browser for Google OAuth consent
2. Save authentication tokens locally
3. Create a `token.pickle` file for future use

## Step 5: Deploy to Cloud (Optional)

### Using Docker

Create `Dockerfile`:

```dockerfile
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

CMD ["python", "calendar_server.py"]
```

Create `requirements.txt`:
```txt
mcp
google-auth
google-auth-oauthlib
google-auth-httplib2
google-api-python-client
```

### Using Cloud Run

```bash
# Build and deploy
gcloud builds submit --tag gcr.io/YOUR_PROJECT/calendar-server
gcloud run deploy calendar-server --image gcr.io/YOUR_PROJECT/calendar-server
```

## Step 6: Connect to Claude Desktop

Add to your configuration:

```json
{
  "mcpServers": {
    "calendar": {
      "command": "python",
      "args": ["/path/to/calendar_server.py"],
      "env": {
        "GOOGLE_APPLICATION_CREDENTIALS": "/path/to/credentials.json"
      }
    }
  }
}
```

## Step 7: Test Your Server

Try these queries with Claude:
- "What's on my calendar this week?"
- "Create a meeting for tomorrow at 2 PM"
- "Show me my events for the next 3 days"

## Advanced Features

### Add Recurring Events

```python
async def create_recurring_event(self, title: str, start_time: str, end_time: str, 
                                recurrence_rule: str):
    """Create a recurring event."""
    event = {
        'summary': title,
        'start': {'dateTime': start_time, 'timeZone': 'UTC'},
        'end': {'dateTime': end_time, 'timeZone': 'UTC'},
        'recurrence': [recurrence_rule]  # e.g., 'RRULE:FREQ=WEEKLY;BYDAY=MO'
    }
    
    return self.service.events().insert(calendarId='primary', body=event).execute()
```

### Add Event Search

```python
async def search_events(self, query: str, max_results: int = 10):
    """Search for events by text query."""
    events_result = self.service.events().list(
        calendarId='primary',
        q=query,
        maxResults=max_results,
        singleEvents=True,
        orderBy='startTime'
    ).execute()
    
    return events_result.get('items', [])
```

### Add Multiple Calendar Support

```python
async def list_calendars(self):
    """List all accessible calendars."""
    calendar_list = self.service.calendarList().list().execute()
    return calendar_list.get('items', [])
```

## Security Best Practices

1. **Credential Management**: Never commit credentials to version control
2. **Token Storage**: Secure token storage in production
3. **Scope Limitation**: Request only necessary OAuth scopes
4. **Rate Limiting**: Implement proper rate limiting
5. **Error Handling**: Don't expose internal details in errors

## Production Considerations

### Environment Variables

```python
CREDENTIALS_FILE = os.getenv('GOOGLE_CREDENTIALS_FILE', 'credentials.json')
TOKEN_FILE = os.getenv('GOOGLE_TOKEN_FILE', 'token.pickle')
```

### Logging and Monitoring

```python
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Add to methods
logger.info(f"Created event: {event['id']}")
logger.error(f"API error: {e}")
```

### Rate Limiting

```python
import time
from functools import wraps

def rate_limit(calls_per_second=10):
    def decorator(func):
        last_called = [0.0]
        
        @wraps(func)
        def wrapper(*args, **kwargs):
            elapsed = time.time() - last_called[0]
            left_to_wait = 1.0 / calls_per_second - elapsed
            if left_to_wait > 0:
                time.sleep(left_to_wait)
            ret = func(*args, **kwargs)
            last_called[0] = time.time()
            return ret
        return wrapper
    return decorator
```

## Troubleshooting

**OAuth Issues:**
- Check redirect URIs in Google Cloud Console
- Verify API is enabled
- Check credential file path

**API Errors:**
- Review quota limits in Google Cloud Console
- Check API permissions and scopes
- Verify calendar access permissions

**Token Expiration:**
- Implement automatic token refresh
- Handle expired token gracefully
- Store refresh tokens securely

## Next Steps

After completing this tutorial:

- Explore [authentication patterns](/docs/how-to-guides/authentication) for other APIs
- Learn about [deployment strategies](/docs/how-to-guides/deployment)
- Study [advanced MCP concepts](/docs/learn/architecture)

This tutorial demonstrates building production-ready MCP servers with real-world API integration, authentication, and deployment considerations.