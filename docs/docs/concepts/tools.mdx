---
title: "Tools"
description: "Enable LLMs to perform actions through your server"
---

Tools are a powerful primitive in the Model Context Protocol (MCP) that enable servers to expose executable functionality to clients. Through tools, LLMs can interact with external systems, perform computations, and take actions in the real world.

<Note>
  Tools are designed to be **model-controlled**, meaning that tools are exposed from servers to clients with the intention of the AI model being able to automatically invoke them (with a human in the loop to grant approval).
</Note>

## Overview

Tools in MCP allow servers to expose executable functions that can be invoked by clients and used by LLMs to perform actions. Key aspects of tools include:

- **Discovery**: Clients can list available tools through the `tools/list` endpoint
- **Invocation**: Tools are called using the `tools/call` endpoint, where servers perform the requested operation and return results
- **Flexibility**: Tools can range from simple calculations to complex API interactions

Like [resources](/docs/concepts/resources), tools are identified by unique names and can include descriptions to guide their usage. However, unlike resources, tools represent dynamic operations that can modify state or interact with external systems.

## Tool definition structure

Each tool is defined with the following structure:

```typescript
{
  name: string;          // Unique identifier for the tool
  description?: string;  // Human-readable description
  inputSchema: {         // JSON Schema for the tool's parameters
    type: "object",
    properties: { ... }  // Tool-specific parameters
  },
  annotations?: {        // Optional hints about tool behavior
    title?: string;      // Human-readable title for the tool
    readOnlyHint?: boolean;    // If true, the tool does not modify its environment
    destructiveHint?: boolean; // If true, the tool may perform destructive updates
    idempotentHint?: boolean;  // If true, repeated calls with same args have no additional effect
    openWorldHint?: boolean;   // If true, tool interacts with external entities
  }
}
```

## Implementing tools

Here's an example of implementing a basic tool in an MCP server:

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    const server = new Server({
      name: "example-server",
      version: "1.0.0"
    }, {
      capabilities: {
        tools: {}
      }
    });

    // Define available tools
    server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [{
          name: "calculate_sum",
          description: "Add two numbers together",
          inputSchema: {
            type: "object",
            properties: {
              a: { type: "number" },
              b: { type: "number" }
            },
            required: ["a", "b"]
          }
        }]
      };
    });

    // Handle tool execution
    server.setRequestHandler(CallToolRequestSchema, async (request) => {
      if (request.params.name === "calculate_sum") {
        const { a, b } = request.params.arguments;
        return {
          content: [
            {
              type: "text",
              text: String(a + b)
            }
          ]
        };
      }
      throw new Error("Tool not found");
    });
    ```
  </Tab>
  <Tab title="Python">
    ```python
    app = Server("example-server")

    @app.list_tools()
    async def list_tools() -> list[types.Tool]:
        return [
            types.Tool(
                name="calculate_sum",
                description="Add two numbers together",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "a": {"type": "number"},
                        "b": {"type": "number"}
                    },
                    "required": ["a", "b"]
                }
            )
        ]

    @app.call_tool()
    async def call_tool(
        name: str,
        arguments: dict
    ) -> list[types.TextContent | types.ImageContent | types.EmbeddedResource]:
        if name == "calculate_sum":
            a = arguments["a"]
            b = arguments["b"]
            result = a + b
            return [types.TextContent(type="text", text=str(result))]
        raise ValueError(f"Tool not found: {name}")
    ```
  </Tab>
</Tabs>

## Example tool patterns

Here are some examples of types of tools that a server could provide:

### System operations

Tools that interact with the local system:

```typescript
{
  name: "execute_command",
  description: "Run a shell command",
  inputSchema: {
    type: "object",
    properties: {
      command: { type: "string" },
      args: { type: "array", items: { type: "string" } }
    }
  }
}
```

### API integrations

Tools that wrap external APIs:

```typescript
{
  name: "github_create_issue",
  description: "Create a GitHub issue",
  inputSchema: {
    type: "object",
    properties: {
      title: { type: "string" },
      body: { type: "string" },
      labels: { type: "array", items: { type: "string" } }
    }
  }
}
```

### Data processing

Tools that transform or analyze data:

```typescript
{
  name: "analyze_csv",
  description: "Analyze a CSV file",
  inputSchema: {
    type: "object",
    properties: {
      filepath: { type: "string" },
      operations: {
        type: "array",
        items: {
          enum: ["sum", "average", "count"]
        }
      }
    }
  }
}
```

## Best practices

When implementing tools:

1. Provide clear, descriptive names and descriptions
2. Use detailed JSON Schema definitions for parameters
3. Include examples in tool descriptions to demonstrate how the model should use them
4. Implement proper error handling and validation
5. Use progress reporting for long operations
6. Keep tool operations focused and atomic
7. Document expected return value structures
8. Implement proper timeouts
9. Consider rate limiting for resource-intensive operations
10. Log tool usage for debugging and monitoring

## Security considerations

When exposing tools:

### Input validation

- Validate all parameters against the schema
- Sanitize file paths and system commands
- Validate URLs and external identifiers
- Check parameter sizes and ranges
- Prevent command injection

### Access control

- Implement authentication where needed
- Use appropriate authorization checks
- Audit tool usage
- Rate limit requests
- Monitor for abuse

### Error handling

- Don't expose internal errors to clients
- Log security-relevant errors
- Handle timeouts appropriately
- Clean up resources after errors
- Validate return values

## Tool discovery and updates

MCP supports dynamic tool discovery:

1. Clients can list available tools at any time
2. Servers can notify clients when tools change using `notifications/tools/list_changed`
3. Tools can be added or removed during runtime
4. Tool definitions can be updated (though this should be done carefully)

## Error handling

Tool errors should be reported within the result object, not as MCP protocol-level errors. This allows the LLM to see and potentially handle the error. When a tool encounters an error:

1. Set `isError` to `true` in the result
2. Include error details in the `content` array

Here's an example of proper error handling for tools:

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    try {
      // Tool operation
      const result = performOperation();
      return {
        content: [
          {
            type: "text",
            text: `Operation successful: ${result}`
          }
        ]
      };
    } catch (error) {
      return {
        isError: true,
        content: [
          {
            type: "text",
            text: `Error: ${error.message}`
          }
        ]
      };
    }
    ```
  </Tab>
  <Tab title="Python">
    ```python
    try:
        # Tool operation
        result = perform_operation()
        return types.CallToolResult(
            content=[
                types.TextContent(
                    type="text",
                    text=f"Operation successful: {result}"
                )
            ]
        )
    except Exception as error:
        return types.CallToolResult(
            isError=True,
            content=[
                types.TextContent(
                    type="text",
                    text=f"Error: {str(error)}"
                )
            ]
        )
    ```
  </Tab>
</Tabs>

This approach allows the LLM to see that an error occurred and potentially take corrective action or request human intervention.

## Tool annotations

Tool annotations provide additional metadata about a tool's behavior, helping clients understand how to present and manage tools. These annotations are hints that describe the nature and impact of a tool, but should not be relied upon for security decisions.

### Purpose of tool annotations

Tool annotations serve several key purposes:

1. Provide UX-specific information without affecting model context
2. Help clients categorize and present tools appropriately
3. Convey information about a tool's potential side effects
4. Assist in developing intuitive interfaces for tool approval
5. Enable appropriate governance policies and security controls

### Available tool annotations

The MCP specification defines the following annotations for tools:

| Annotation | Type | Default | Description |
|------------|------|---------|-------------|
| `title` | string | - | A human-readable title for the tool, useful for UI display |
| `readOnlyHint` | boolean | false | If true, indicates the tool does not modify its environment |
| `destructiveHint` | boolean | true | If true, the tool may perform destructive updates (only meaningful when `readOnlyHint` is false) |
| `idempotentHint` | boolean | false | If true, calling the tool repeatedly with the same arguments has no additional effect (only meaningful when `readOnlyHint` is false) |
| `openWorldHint` | boolean | true | If true, the tool may interact with an "open world" of external entities |
| `aiProcessingHint` | boolean | false | If true, the tool involves AI or LLM processing |
| `slowExecutionHint` | boolean | false | If true, the tool typically takes a long time to execute |
| `resourceIntensiveHint` | boolean | false | If true, the tool is resource-intensive (CPU, memory, or disk) |
| `sensitiveDataHint` | boolean | false | If true, the tool processes or has access to sensitive data |
| `privilegedAccessHint` | boolean | false | If true, the tool requires elevated system privileges |
| `reversibleHint` | boolean | false | If true, the tool's operations can be undone or reversed |

### Detailed annotation descriptions

#### Basic Operation Annotations

**`title`**: Provides a human-friendly display name for the tool.
- Example: Tool name `gh_create_issue` â†’ Title `"Create GitHub Issue"`

**`readOnlyHint`**: Indicates whether the tool modifies its environment.
- `true`: `search_database`, `get_weather`, `read_file`
- `false`: `create_user`, `delete_file`, `send_email`

**`destructiveHint`**: For non-read-only tools, indicates if changes are destructive.
- `true`: `delete_file`, `drop_database_table`, `factory_reset`
- `false`: `create_backup`, `add_user`, `append_to_log`

**`idempotentHint`**: For non-read-only tools, indicates if repeated calls have the same effect.
- `true`: `set_user_status`, `ensure_directory_exists`
- `false`: `increment_counter`, `append_to_file`, `send_notification`

**`openWorldHint`**: Indicates whether the tool interacts with external, uncontrolled entities.
- `true`: `web_search`, `external_api_call`, `fetch_url`
- `false`: `local_database_query`, `memory_store`, `file_system_operation`

#### AI and Processing Annotations

**`aiProcessingHint`**: Indicates AI/ML model usage for governance policies.
- `true`: `generate_text`, `analyze_sentiment`, `create_embedding`
- `false`: `database_query`, `file_upload`, `send_email`

**`slowExecutionHint`**: Helps clients manage user expectations and timeouts.
- `true`: `large_file_processing`, `model_training`, `video_encoding`
- `false`: `simple_calculation`, `cache_lookup`, `status_check`

**`resourceIntensiveHint`**: Helps clients manage system resources.
- `true`: `image_processing`, `data_compression`, `crypto_mining`
- `false`: `text_formatting`, `simple_math`, `configuration_read`

#### Security and Access Annotations

**`sensitiveDataHint`**: Indicates handling of confidential information.
- `true`: `access_user_passwords`, `read_financial_records`, `process_medical_data`
- `false`: `get_weather`, `public_api_lookup`, `system_time`

**`privilegedAccessHint`**: Indicates need for elevated system permissions.
- `true`: `install_software`, `modify_system_config`, `restart_service`
- `false`: `read_user_file`, `send_http_request`, `calculate_hash`

**`reversibleHint`**: For non-read-only tools, indicates if operations can be undone.
- `true`: `create_backup` (can be deleted), `rename_file` (can rename back)
- `false`: `send_email` (cannot unsend), `delete_permanently`

### Comprehensive example usage

Here are real-world examples showing how to use annotations effectively:

```typescript
// AI-powered code analysis tool
{
  name: "analyze_code_with_ai",
  description: "Analyze code quality and security using AI",
  inputSchema: {
    type: "object",
    properties: {
      code: { type: "string" },
      language: { type: "string" }
    },
    required: ["code"]
  },
  annotations: {
    title: "AI Code Analyzer",
    readOnlyHint: true,
    openWorldHint: true,
    aiProcessingHint: true,
    slowExecutionHint: true,
    sensitiveDataHint: true
  }
}

// System service management tool
{
  name: "restart_service",
  description: "Restart a system service",
  inputSchema: {
    type: "object",
    properties: {
      service_name: { type: "string" }
    },
    required: ["service_name"]
  },
  annotations: {
    title: "Restart Service",
    readOnlyHint: false,
    destructiveHint: false,
    idempotentHint: true,
    openWorldHint: false,
    privilegedAccessHint: true,
    reversibleHint: true
  }
}

// Large file processing tool
{
  name: "compress_video",
  description: "Compress video files to reduce size",
  inputSchema: {
    type: "object",
    properties: {
      input_path: { type: "string" },
      output_path: { type: "string" },
      quality: { type: "string" }
    },
    required: ["input_path", "output_path"]
  },
  annotations: {
    title: "Video Compressor",
    readOnlyHint: false,
    destructiveHint: false,
    openWorldHint: false,
    slowExecutionHint: true,
    resourceIntensiveHint: true,
    reversibleHint: false
  }
}

// External API integration
{
  name: "send_slack_message",
  description: "Send a message to a Slack channel",
  inputSchema: {
    type: "object",
    properties: {
      channel: { type: "string" },
      message: { type: "string" }
    },
    required: ["channel", "message"]
  },
  annotations: {
    title: "Send Slack Message",
    readOnlyHint: false,
    destructiveHint: false,
    idempotentHint: false,
    openWorldHint: true,
    reversibleHint: false
  }
}

// Database backup tool
{
  name: "backup_database",
  description: "Create a backup of the database",
  inputSchema: {
    type: "object",
    properties: {
      database_name: { type: "string" },
      backup_path: { type: "string" }
    },
    required: ["database_name"]
  },
  annotations: {
    title: "Database Backup",
    readOnlyHint: false,
    destructiveHint: false,
    idempotentHint: true,
    openWorldHint: false,
    slowExecutionHint: true,
    resourceIntensiveHint: true,
    sensitiveDataHint: true,
    privilegedAccessHint: true,
    reversibleHint: true
  }
}

// Simple calculation tool
{
  name: "calculate_fibonacci",
  description: "Calculate the nth Fibonacci number",
  inputSchema: {
    type: "object",
    properties: {
      n: { type: "number" }
    },
    required: ["n"]
  },
  annotations: {
    title: "Fibonacci Calculator",
    readOnlyHint: true,
    openWorldHint: false
    // Most hints default to false and don't need to be specified
  }
}
```

### Integrating annotations in server implementation

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [{
          name: "ai_text_generator",
          description: "Generate text using AI models",
          inputSchema: {
            type: "object",
            properties: {
              prompt: { type: "string" },
              max_tokens: { type: "number" }
            },
            required: ["prompt"]
          },
          annotations: {
            title: "AI Text Generator",
            readOnlyHint: false,
            destructiveHint: false,
            openWorldHint: true,
            aiProcessingHint: true,
            slowExecutionHint: true,
            sensitiveDataHint: true
          }
        }]
      };
    });
    ```
  </Tab>
  <Tab title="Python">
    ```python
    from mcp.server.fastmcp import FastMCP
    
    mcp = FastMCP("example-server")
    
    @mcp.tool(
        annotations={
            "title": "System Log Analyzer",
            "readOnlyHint": True,
            "openWorldHint": False,
            "slowExecutionHint": True,
            "resourceIntensiveHint": True,
            "privilegedAccessHint": True,
            "sensitiveDataHint": False
        }
    )
    async def analyze_system_logs(log_path: str) -> str:
        """Analyze system logs for patterns and issues.
        
        Args:
            log_path: Path to the log file to analyze
        """
        # Implementation here
        return "Analysis complete"
    ```
  </Tab>
</Tabs>

### Best practices for tool annotations

1. **Be accurate about side effects**: Clearly indicate whether a tool modifies its environment and whether those modifications are destructive.

2. **Use descriptive titles**: Provide human-friendly titles that clearly describe the tool's purpose.

3. **Consider security implications**: Use `sensitiveDataHint` and `privilegedAccessHint` to help clients implement appropriate security controls.

4. **Help with resource management**: Use `slowExecutionHint` and `resourceIntensiveHint` to enable better UX and system resource management.

5. **Enable AI governance**: Use `aiProcessingHint` to support organizational policies around AI tool usage.

6. **Indicate reversibility**: Use `reversibleHint` to help users understand whether operations can be undone.

7. **Remember annotations are hints**: All properties in ToolAnnotations are hints and not guaranteed to provide a faithful description of tool behavior. Clients should never make security-critical decisions based solely on annotations.

## Testing tools

A comprehensive testing strategy for MCP tools should cover:

- **Functional testing**: Verify tools execute correctly with valid inputs and handle invalid inputs appropriately
- **Integration testing**: Test tool interaction with external systems using both real and mocked dependencies
- **Security testing**: Validate authentication, authorization, input sanitization, and rate limiting
- **Performance testing**: Check behavior under load, timeout handling, and resource cleanup
- **Error handling**: Ensure tools properly report errors through the MCP protocol and clean up resources
